---
layout:     post
title:      递归与闭包
subtitle:   javascript语法
date:       2018-05-08
author:     BY Jacky
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Javascipt
    - 递归 
---

API服务器还没有修复，这就可厉害了，躁动的想撸代码。。。

### 递归

* 什么是递归？

在程序中，递归就是函数自己直接或间接的调用自己。

* 递归的要素？

   1 自己调用自己

   2 要有结束条件


* 化归思想

将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。

这里更多的是根据一些例子来体会和感受递归的思想，让我们开始吧！

栗子1： 求1~100之和

```
  // 将求100转换为求99
  // 将求99转换为求98
  // ...
  // 将求2转换为求1
  // 求1结果就是1
  // 即：sum(1)是1
  function sum(n){
    if(n == 1){
      return 1;
    }
    return sum(n - 1) + n;
  }
  
  var num = sum(100);
  console.log(num); // 5050
```

栗子2： 求阶乘

```
  // 1!  1
  // 2!  1! * 2
  // 3!  2! * 3
  // ...
  // n!  (n-1)! * n
  function factorial(n){
    if( n == 1){
      return 1;
    }
    return factorial(n - 1) * n;
  }
  
  // 5! = 1 * 2 * 3 * 4 * 5
  console.log(factorial(5)); // 120
```

栗子3： 求幂

```
  // 1 的 m 次方   1 * 1^(m - 1) = 1^m = 1
  // 2 的 m 次方   m 个 2 相乘 2 * 2^(m - 1) = 2^m
  // ...
  // n 的 m 次方   m 个 n 相乘 即 n * n^(m - 1) = n^m
  // 每个数的 1 次方都等于它本身，如2^1 = 2; 3^1 = 3 等
  function power(n, m){
    if(m == 1){
      return n;
    }
    return power(n, m-1) * n;
  }
  console.log(power(4,3)); // 48  //4*4*4=48
```

栗子4： 斐波那契数列

```
  // 斐波那契数列: 1 1 2 3 5 8 13 21 34 ...
  // 从第三项开始，后面一项的值为前面两项相加之和
  
  // 第一项  1
  // 第二项  1
  // 第三项  1 + 1 = 2
  // 第四项  1 + 2 = 3
  // ...
  // 第n项   (n - 2) + (n - 1) = n
  function fibonacci(n){
    if(n <= 2){
      return 1;
    }
    return fibonacci(n - 2) + fibonacci(n - 1);
  }
  console.log(fibonacci(10)); //55
```

栗子5： 给页面中的所有元素添加边框

```
  // DOM中没有直接获取后代元素的API
  // 可以通过chaildNodes来获取所有的子节点
  
  function getChildNodes(node){
    // 先找子元素
    var nodeList = node.childNodes;
    // 再用子元素找子元素（递归）
    // for循环中的条件，就充当了结束条件
    for(var i = 0; i < nodeList.length; i++){
      // childNode获取到的节点包含了各种类型的节点 
      // 只需要元素节点 通过nodeType判断当前节点是否为元素节点
      // 节点.nodeType == 1 元素节点/2 属性节点/3 文本节点
      var childNode = nodeList[i];
      // 判断是否为元素节点
      if(childNodes.nodeType == 1){
        childNode.style.border = '1px solid red';
        getChildNode(childNode);
      }
    }
  }
  
  getChildNode(document.body);
```

代码优化升级：

```
  function getChildNode(onode){
    var nodeList = node.childNodes;
    var res = [];
    
    for(var i = 0; i < nodeList.length; i++){
      var childNode = nodeList[i];
      if(childNode.nodeType ==1){
        res.push(childNode);
        var temp = getChildNode(childNode0;
        res = res.concat(temp);
      }
    }
    return res;
  }
  
  // 1. 第一次调用时获取body的所有子元素，会把所有的子元素全部放到res里面
  // 2. 没放进去一个就找这个子元素的所有子元素 有返回值
  // 3. 把这个返回值和存当前子元素的数组拼接起来，就变成子元素和孙子元素的集合
  var arr = getChildNode(document.body);
  
  for(var i = 0; i < arr.length; i++){
    var child = arr[i];
    child.style.border = '1px solid red';
  }
```

效果如下图： 

![pic1 icon](http://f.cl.ly/items/163S2L2a3i2o1P2F1o3b/111.png)





























